var documenterSearchIndex = {"docs":
[{"location":"day11/#Day-11:-Monkey-in-the-Middle","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"","category":"section"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"Monkeys throwing around packets... I first tried this with some Julia meta-programming, but it turns out that good old static function composition is much faster. If I run Julia at -O0 versus -O3 the soft version is just a few procent slower, but the meta-programming version gets twice as fast (still twice as slow as the soft version). Basically LLVM is just too slow to make this an interesting option for now.","category":"page"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"As for the problem: I reduced the numbers in size by taking the modulo with the product of all the primes that we are testing divisibility against.","category":"page"},{"location":"day11/#Parsing-input","page":"Day 11: Monkey in the Middle","title":"Parsing input","text":"","category":"section"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"Today the input was given in the form of some quasi-yaml, so I wrote a quasi-yaml parser. This parser finds the indentation of each line and splits the contents on a colon. If the indentation was increased w.r.t. the previous step, we go one level deeper. If indentation decreased, we pop the stack until we're at the right indent level again. We get back a nested dictionary with string keys.","category":"page"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"<div class=\"noweb-label\">⪡quasi-yaml⪢≣</div>","category":"page"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"mutable struct QYPair\n    value::String\n    child::Union{Nothing,Dict{String,QYPair}}\nend\n\nBase.getindex(qy::QYPair, s::AbstractString) = qy.child[s]\n\nfunction read_quasi_yaml(inp::IO)\n    result = Dict{String,QYPair}()\n    stack = [result]\n    prev = result\n    indents = [0]\n    line_r = r\"^(\\s*)([^:]+):\\s*([^:]*)$\"\n    for l in eachline(inp)\n        m = match(line_r, l)\n        isnothing(m) && continue\n        new_indent = length(m[1])\n        if new_indent > last(indents)\n            prev.child = Dict{String,QYPair}()\n            push!(stack, prev.child)\n            push!(indents, new_indent)\n        else\n            while new_indent < last(indents)\n                pop!(stack)\n                pop!(indents)\n            end\n            @assert (new_indent == last(indents))\n        end\n        prev = QYPair(m[3], nothing)\n        last(stack)[m[2]] = prev\n    end\n    result\nend","category":"page"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"Once we have the quasi-yaml parsed, we can extract information on each monkey into a MonkeySpec.","category":"page"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"<div class=\"noweb-label\">⪡monkey-spec⪢≣</div>","category":"page"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"struct MonkeySpec\n    start::Vector{Int}\n    operation::Expr\n    test_factor::Int\n    if_true::Int\n    if_false::Int\nend\n\nfunction read_input(inp::IO)\n    qy = read_quasi_yaml(inp)\n    monkeys = Vector{MonkeySpec}(undef, length(qy))\n    for (k, m) in qy\n        n = parse.(Int, match(r\"Monkey (\\d+)\", k)[1]) + 1\n        start = parse.(Int, split(m[\"Starting items\"].value, \", \"))\n        operation = Meta.parse(m[\"Operation\"].value)\n        test_factor = parse(Int, match(r\"divisible by (\\d+)\", m[\"Test\"].value)[1])\n        action(s) = parse(Int, match(r\"throw to monkey (\\d+)\", s)[1]) + 1\n        if_true = action(m[\"Test\"][\"If true\"].value)\n        if_false = action(m[\"Test\"][\"If false\"].value)\n        monkeys[n] = MonkeySpec(start, operation, test_factor, if_true, if_false)\n    end\n    monkeys\nend","category":"page"},{"location":"day11/#Simulating-Monkeys","page":"Day 11: Monkey in the Middle","title":"Simulating Monkeys","text":"","category":"section"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"Now I have two implementations of monkey simulators: a higher order function and a code generator. The soft version uses knowledge about the limitations of the expressions that we can encounter, creating some closure to do the actual work.","category":"page"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"<div class=\"noweb-label\">⪡monkey-simulator⪢≣</div>","category":"page"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"mutable struct Monkey\n    items::Vector{Int}\n    round::Function\n    count::Int\nend\n\nfunction send(m::Monkey, v::Int)\n    push!(m.items, v)\nend\n\nfunction monkey_soft(spec::MonkeySpec, worry_reduction::Function)\n    op = spec.operation.args[2].args[1]\n    num = spec.operation.args[2].args[3]\n    if num isa Int\n        func = op === :+ ? (x -> x + num) : (x -> x * num)\n    else\n        func = op === :+ ? (x -> x + x) : (x -> x * x)\n    end\n    function(self::Monkey, others::Vector{Monkey})\n        for old in self.items\n            self.count += 1\n            new = worry_reduction(func(old))\n            send(others[rem(new, spec.test_factor) == 0 ? spec.if_true : spec.if_false], new)\n        end\n        empty!(self.items)\n    end\nend","category":"page"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"The generated version uses the Julia integrated compiler to generate a function from the ingredients that we were given. This should give more efficient code, but has the overhead that we need to compile this function for every monkey. Currently, the Julia compiler is too slow to make this implementation competetive with the soft implementation.","category":"page"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"<div class=\"noweb-label\">⪡monkey-simulator⪢⊞</div>","category":"page"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"function monkey_gen(spec::MonkeySpec, worry_reduction::Function)\n    @eval begin\n        function(self::Monkey, others::Vector{Monkey})\n            for old in self.items\n                self.count += 1\n                $(spec.operation)\n                new = $(worry_reduction)(new)\n\n                if rem(new, $(spec.test_factor)) == 0\n                    send(others[$(spec.if_true)], new)\n                else\n                    send(others[$(spec.if_false)], new)\n                end\n            end\n            empty!(self.items)\n        end\n    end\nend","category":"page"},{"location":"day11/#Running-the-lot","page":"Day 11: Monkey in the Middle","title":"Running the lot","text":"","category":"section"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"<div class=\"noweb-label\">file:<i>src/day11.jl</i></div>","category":"page"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"module Day11\n\n<<quasi-yaml>>\n<<monkey-spec>>\n<<monkey-simulator>>\n\ninit_monkeys(spec::Vector{MonkeySpec}, worry_reduction::Function) =\n    [Monkey(copy(s.start), monkey_soft(s, worry_reduction), 0) for s in spec]\n\nmonkey_business(monkeys::Vector{Monkey}) =\n    *(sort(monkeys .|> m -> m.count)[end-1:end]...)\n\nfunction run_monkeys(monkeys::Vector{Monkey}, n_rounds::Int)\n    for _ in 1:n_rounds\n        for m in monkeys\n            Base.invokelatest(m.round, m, monkeys)\n        end\n    end\n    monkeys\nend\n\nfunction main(inp::IO, out::IO)\n    input = read_input(inp)\n    part1 = monkey_business(run_monkeys(init_monkeys(input, x -> x ÷ 3), 20))\n    println(out,\"Part 1: $part1\")\n    max_factor = foldl(*, (s.test_factor for s in input))\n    part2 = monkey_business(run_monkeys(init_monkeys(input, x -> x % max_factor), 10000))\n    println(out, \"Part 2: $part2\")\nend\n\nend  # module","category":"page"},{"location":"day11/","page":"Day 11: Monkey in the Middle","title":"Day 11: Monkey in the Middle","text":"using AOC2022  # hide\n@day 11","category":"page"},{"location":"day09/#Day-09:-Rope-Bridge","page":"Day 09: Rope Bridge","title":"Day 09: Rope Bridge","text":"","category":"section"},{"location":"day09/","page":"Day 09: Rope Bridge","title":"Day 09: Rope Bridge","text":"<div class=\"noweb-label\">file:<i>src/day09.jl</i></div>","category":"page"},{"location":"day09/","page":"Day 09: Rope Bridge","title":"Day 09: Rope Bridge","text":"module Day09\n\nexport read_input, State, make_move!\n\nconst Pt2 = Tuple{Int,Int}\n\nstruct Move\n    d::Pt2\n    s::Int\nend\n\nmutable struct State\n    rope::Vector{Pt2}\n    history::Set{Pt2}\nend\n\nconst directions = Dict{Char,Pt2}(\n    'L' => (-1,0), 'R' => (1,0), 'U' => (0,1), 'D' => (0,-1))\n\nBase.parse(::Type{Move}, line::AbstractString) =\n    Move(directions[line[1]], parse(Int, line[3:end]))\n\nread_input(io::IO) =\n    parse.(Move, readlines(io))\n\nfunction make_move!(st::State, m::Move)\n    for _ in 1:m.s\n        st.rope[1] = st.rope[1] .+ m.d\n        for (i,x) in enumerate(st.rope[2:end])\n            dist = st.rope[i] .- x\n            if max(abs.(dist)...) > 1\n                st.rope[i+1] = x .+ sign.(dist)\n            end\n        end\n        push!(st.history, st.rope[end])\n    end\nend\n\nfunction main(io::IO, io_out::IO=stdout)\n    input = read_input(io)\n    st = State([(0,0), (0,0)], Set([(0,0)]))\n    foreach(m->make_move!(st, m), input)\n    println(io_out, \"Part 1: $(length(st.history))\")\n    st = State(fill((0,0), 10), Set([(0,0)]))\n    foreach(m->make_move!(st, m), input)\n    println(io_out, \"Part 2: $(length(st.history))\")\nend\n\nend  # module","category":"page"},{"location":"day09/","page":"Day 09: Rope Bridge","title":"Day 09: Rope Bridge","text":"using AOC2022  # hide\n@day 9","category":"page"},{"location":"day09/#Movie","page":"Day 09: Rope Bridge","title":"Movie","text":"","category":"section"},{"location":"day09/","page":"Day 09: Rope Bridge","title":"Day 09: Rope Bridge","text":"<div class=\"noweb-label\">file:<i>src/day09-movie.jl</i></div>","category":"page"},{"location":"day09/","page":"Day 09: Rope Bridge","title":"Day 09: Rope Bridge","text":"module Day09Movie\n\ninclude(\"day09.jl\")\nusing .Day09\n#using GLMakie\nusing CairoMakie\n\nexport plot_state!, State, make_move!, read_input\n\nfunction plot_state!(ax, st::State)\n    pts = foldl(hcat, st.rope .|> e -> [e...])'\n    lines!(ax, pts[:,1], pts[:,2])\nend\n\nend  # module","category":"page"},{"location":"day12/#Day-12:-Hill-Climbing-Algorithm","page":"Day 12: Hill Climbing Algorithm","title":"Day 12: Hill Climbing Algorithm","text":"","category":"section"},{"location":"day12/","page":"Day 12: Hill Climbing Algorithm","title":"Day 12: Hill Climbing Algorithm","text":"<div class=\"noweb-label\">file:<i>src/day12.jl</i></div>","category":"page"},{"location":"day12/","page":"Day 12: Hill Climbing Algorithm","title":"Day 12: Hill Climbing Algorithm","text":"module Day12\n\nusing Base: splat\nusing DataStructures: PriorityQueue, enqueue!, dequeue!\nexport read_input, part1, trace_back\n\nfunction read_input(io::IO)\n    data = foldl(hcat, Vector{Char}.(readlines(io)))\n    target = findfirst(c -> c == 'E', data)\n    start = findfirst(c -> c == 'S', data)\n    data[start] = 'a'\n    data[target] = 'z'\n    (height = data .- 'a', start = start, target = target)\nend\n\nfunction grid_dijkstra(\n        DistType::Type{T}, size, \n        start::CartesianIndex, istarget::Function,\n        neighbours::Function, dist_func::Function) where {T}\n    visited = fill(false, size)\n    distance = fill(typemax(T), size)\n    distance[start] = zero(T)\n    queue = PriorityQueue{CartesianIndex,T}()\n    prev = Matrix{CartesianIndex}(undef, size)\n    enqueue!(queue, start, zero(T))\n    current = nothing\n    while !isempty(queue)\n        current = dequeue!(queue)\n        istarget(current) && break\n        visited[current] && continue\n        for loc in neighbours(current)\n            visited[loc] && continue\n            d = distance[current] + dist_func(current, loc)\n            if d < distance[loc]\n                distance[loc] = d\n                prev[loc] = current\n                enqueue!(queue, loc, d)\n            end\n        end\n        visited[current] = true\n    end\n    (distance = distance, route = prev, target = current)\nend\n\nconst grid_neighbours =\n    eachrow([0 1; 0 -1; 1 0; -1 0]) .|> splat(CartesianIndex)\n\nfunction trace_back(prev, start, target)\n    route = [target]\n    current = target\n    while current != start\n        current = prev[current]\n        pushfirst!(route, current)\n    end\n    route\nend\n\nfunction main(inp::IO, out::IO)\n    input = read_input(inp)\n    ok_step(a, b) = input.height[b] - input.height[a] <= 1\n    in_bounds(a) = checkbounds(Bool, input.height, a)\n    dist_func(a, b) = 1\n\n    function part1()\n        neighbours(pt) = (nb for nb in (grid_neighbours .+ (pt,)) if in_bounds(nb) && ok_step(pt, nb))\n        grid_dijkstra(Int,\n            size(input.height),\n            input.start,\n            x -> x == input.target,\n            neighbours, dist_func)\n    end\n\n    function part2()\n        neighbours(pt) = (nb for nb in (grid_neighbours .+ (pt,)) if in_bounds(nb) && ok_step(nb, pt))\n        grid_dijkstra(Int,\n            size(input.height),\n            input.target,\n            x -> input.height[x] == 0,\n            neighbours, dist_func)\n    end\n\n    result = part1()\n    println(out, \"Part 1: $(result.distance[result.target])\")\n    result = part2()\n    println(out, \"Part 2: $(result.distance[result.target])\")\nend\n\nend  # module","category":"page"},{"location":"day01/#Day-01:-Calorie-Counting","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"","category":"section"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"Adding up numbers! I solved today's exercise in both Julia and Rust, as I'm still unsure in what language to do the rest. Julia gives beautiful clutter free code, Rust gives the nice guarantees of a decent type system. ","category":"page"},{"location":"day01/#Rust","page":"Day 01: Calorie Counting","title":"Rust","text":"","category":"section"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"The first thing we need to do (in any Rust project) is to define an Error type, and a specialised Result. It is idiomatic to have specialised Result this way. A lot of functions in Rust return their own kind of Result, which we can map_err to ours. This way we can collect errors from different sources. For now, we just have input errors.","category":"page"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"<div class=\"noweb-label\">file:<i>src/aoc.rs</i></div>","category":"page"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"#![allow(dead_code)]\n\n#[derive(Debug)]\npub enum Error {\n    Input(String),\n    Value(String)\n}\n\npub type Result<T> = core::result::Result<T, Error>;\n\npub fn input_error<T>(err:T) -> Error where T: core::fmt::Debug {\n    Error::Input(format!(\"{:?}\", err))\n}","category":"page"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"Our input has lists of integers that are separated by an empty line. We store this in a Vec<Vec<u32>>.","category":"page"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"<div class=\"noweb-label\">⪡read-lists-of-int⪢≣</div>","category":"page"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"fn read_input() -> Result<Vec<Vec<u32>>> {\n    let mut v = Vec::<u32>::new();\n    let mut result = Vec::new();\n    for line in io::stdin().lines() {\n        let l = line.map_err(input_error)?;\n        if l.is_empty() {\n            result.push(v);\n            v = Vec::<u32>::new();\n        } else {\n            v.push(l.parse().map_err(input_error)?);\n        }\n    }\n    if !v.is_empty() {\n        result.push(v);\n    }\n    Ok(result)\n}","category":"page"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"Note how smart Rust is here. When we call result.push(v) the vector v is moved into the result vector. After that the contents of v are no longer accessible through v. This is Ok though, since we immediately construct a new vector to continue with.","category":"page"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"To compute the sums of each input vector, I find the syntax a bit wordy.","category":"page"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"<div class=\"noweb-label\">file:<i>src/day01.rs</i></div>","category":"page"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"mod aoc;\n\nuse crate::aoc::{Error,Result,input_error};\nuse std::io;\n\n<<read-lists-of-int>>\n\nfn main() -> Result<()> {\n    let input = read_input()?;\n    let mut sums: Vec<u32> = input.iter().map(|x| { x.iter().sum::<u32>() }).collect();\n\n    let part1 = sums.iter().max().ok_or(Error::Input(\"Empty input\".to_string()))?;\n    println!(\"Part 1: {}\", part1);\n\n    sums.sort();\n    let part2: u32 = sums[sums.len()-3..].iter().sum();\n    println!(\"Part 2: {}\", part2);\n    Ok(())\n}","category":"page"},{"location":"day01/#Julia","page":"Day 01: Calorie Counting","title":"Julia","text":"","category":"section"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"In Julia I was able to write a bit more abstract code from the get-go. This should also be possible in Rust, but it was harder to think about all the traits. So we have a generic function for splitting an iterable into chunks:","category":"page"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"<div class=\"noweb-label\">⪡function-split-on⪢≣</div>","category":"page"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"function split_on(lst, sep)\n    Channel() do channel\n        v = []\n        for item in lst\n            if item == sep\n                put!(channel, v)\n                v = []\n            else\n                push!(v, item)\n            end\n        end\n        if !isempty(v)\n            put!(channel, v)\n        end\n    end\nend","category":"page"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"Then the rest of the program follows.","category":"page"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"<div class=\"noweb-label\">file:<i>src/day01.jl</i></div>","category":"page"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"module Day01\n\nexport main\n\n<<function-split-on>>\n\nfunction read_input(io::IO=stdin)\n    map(sub -> parse.(Int, sub), split_on(readlines(io), \"\"))\nend\n\nfunction main(io_in::IO, io_out::IO=stdout)\n    input = read_input(io_in)\n    part1 = maximum(sum.(input))\n    println(io_out, \"Part 1: $part1\")\n    part2 = sum(sort(sum.(input))[end-3:end])\n    println(io_out, \"Part 2: $part2\")\nend\n\nend  # module","category":"page"},{"location":"day01/","page":"Day 01: Calorie Counting","title":"Day 01: Calorie Counting","text":"using AOC2022  # hide\n@day 01","category":"page"},{"location":"day05/#Day-05:-Supply-Stacks","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"","category":"section"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"We need to move crates from a start configuration. I store the data (stack and instructions) in a struct.","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"<div class=\"noweb-label\">⪡supply-stacks⪢≣</div>","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"const Crates = Vector{Vector{Char}}\n\nstruct Move\n    amount::Int\n    from::Int\n    to::Int\nend\n\nmutable struct State\n    crates::Crates\n    instructions::Vector{Move}\nend","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"The CrateMover-9000 uses a one-by-one stack operation to move crates.","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"<div class=\"noweb-label\">⪡crate-mover⪢≣</div>","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"crate_mover_9000(crates::Crates) = function (m::Move)\n    for _ in 1:m.amount\n        x = pop!(crates[m.from])\n        push!(crates[m.to], x)\n    end\nend","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"Here I've hand-curried the crate_mover_9000 function, to make it easier to work with the foreach function:","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"<div class=\"noweb-label\">⪡crate-mover⪢⊞</div>","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"function run(crane::Function, st::State)\n    foreach(crane(st.crates), st.instructions)\n    st\nend","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"For the CrateMover-9001 we can use array slicing to do what we want.","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"<div class=\"noweb-label\">⪡crate-mover⪢⊞</div>","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"crate_mover_9001(crates::Crates) = function (m::Move)\n    x = crates[m.from][end-m.amount+1:end]\n    crates[m.from] = crates[m.from][1:end-m.amount]\n    append!(crates[m.to], x)\nend","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"using AOC2022.Day05: read_input, run, crate_mover_9000, crate_mover_9001, Crates\nusing AOC2022.Day05Figure: plot\nusing CairoMakie\n\nCairoMakie.activate!(type = \"svg\")\ndata = open(read_input, \"../../data/day05.txt\", \"r\")\n\npart1 = run(crate_mover_9000, deepcopy(data))\npart2 = run(crate_mover_9001, deepcopy(data))\n\nwith_theme(theme_black()) do\n    fig = Figure(fonts=(; regular=\"serif\"))\n    ax_args = Dict(\n        :limits => (0.2, 9.8, -0.3, 27.3),\n        :aspect => DataAspect(),\n        :xtickalign => 1,\n        :ytickalign => 1,\n        # :xticksmirrored => true,\n        # :yticksmirrored => true,\n        :xticks => 1:9,\n        :yticks => 0:5:25,\n        :titlefont => :regular)\n    plot(data.crates, fig=fig, ax=Axis(fig[1,1]; title=\"input\", ax_args...))\n    plot(part1.crates, fig=fig, ax=Axis(fig[1,2]; title=\"CrateMover9000\", ax_args...))\n    plot(part2.crates, fig=fig, ax=Axis(fig[1,3]; title=\"CrateMover9001\", ax_args...))\n    save(\"day05-result.svg\", fig)\nend","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"(Image: Stack after Part 2)","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"<div class=\"noweb-label\">file:<i>src/day05.jl</i></div>","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"module Day05\n\n<<supply-stacks>>\n<<crate-mover>>\n<<day05-read-input>>\n\nfunction main(io::IO, io_out::IO=stdout)\n    input = read_input(io)\n    part1 = run(crate_mover_9000, deepcopy(input))\n    println(io_out,\"Part 1: $(last.(part1.crates) |> String)\")\n    part2 = run(crate_mover_9001, deepcopy(input))\n    println(io_out,\"Part 2: $(last.(part2.crates) |> String)\")\nend\n\nend  # module","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"using AOC2022  # hide\n@day 5","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"On Reddit u/i_have_no_biscuits constructed an additional input with a hidden message:","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"open(AOC2022.Day05.main, \"../../data/day05-msg.txt\", \"r\")","category":"page"},{"location":"day05/#Reading-input","page":"Day 05: Supply Stacks","title":"Reading input","text":"","category":"section"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"<div class=\"noweb-label\">⪡day05-read-input⪢≣</div>","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"function Base.parse(::Type{Move}, line)\n    r = r\"move (\\d+) from (\\d+) to (\\d+)\"\n    m = match(r, line)\n    isnothing(m) ? nothing : Move(parse.(Int, m)...)\nend\n\nfunction read_input(io::IO)\n    lines = collect(readlines(io))\n    crates = [[] for _ in 1:9]\n    for l in lines\n        if !contains(l, r\"\\[[A-Z]\\]\")\n            break\n        end\n        for j in 1:9\n            c = l[(j-1)*4+2]\n            if c != ' '\n                pushfirst!(crates[j], c)\n            end\n        end\n    end\n\n    instructions = filter(!isnothing, lines .|> l->parse(Move, l))\n    State(crates, instructions)\nend","category":"page"},{"location":"day05/#Plotting-code","page":"Day 05: Supply Stacks","title":"Plotting code","text":"","category":"section"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"<div class=\"noweb-label\">file:<i>src/day05-figure.jl</i></div>","category":"page"},{"location":"day05/","page":"Day 05: Supply Stacks","title":"Day 05: Supply Stacks","text":"module Day05Figure\n\nexport plot\n\nusing Makie\nusing Makie.GeometryBasics\n\ninclude(\"day05.jl\")\nusing .Day05: Crates\n\nunzip(lst) = (getindex.(lst,1), getindex.(lst,2))\n\ncrates_to_rects(crates::Crates) =\n    unzip([(Rect(i-0.45, j-0.95, 0.9, 0.9), k - 'A')\n           for i in 1:9\n           for (j, k) in enumerate(crates[i])])\n\nplot(crates::Crates; fig=nothing, ax=nothing) = begin\n    if ax === nothing\n        fig = Figure()\n        ax = Axis(fig[1,1]; aspect=DataAspect(), \n            xticksmirrored = true, yticksmirrored = true,\n            xticks=1:9, yticks=0:5:25)\n    end\n    crates |> crates_to_rects |>\n        r -> poly!(ax, r[1], color = r[2], colormap = :roma)\n    for i in 1:9\n        for (j, k) in enumerate(crates[i])\n            text!(ax, i, j-0.5, text=\"$k\", align=(:center,:center), color=:black)\n        end\n    end\n    fig\nend\n\nend  # module","category":"page"},{"location":"day04/#Day-04:-Camp-Cleanup","page":"Day 04: Camp Cleanup","title":"Day 04: Camp Cleanup","text":"","category":"section"},{"location":"day04/","page":"Day 04: Camp Cleanup","title":"Day 04: Camp Cleanup","text":"Overlapping ranges. In the first problem we need to see if two ranges completely overlap. I couldn't think of a faster way than to check that either A contains B or B contains A. This is a stronger bound than what we have in the second part. To check for overlap we can compare the maximum of start values with the minimum of stop values.","category":"page"},{"location":"day04/","page":"Day 04: Camp Cleanup","title":"Day 04: Camp Cleanup","text":"<div class=\"noweb-label\">file:<i>src/day04.jl</i></div>","category":"page"},{"location":"day04/","page":"Day 04: Camp Cleanup","title":"Day 04: Camp Cleanup","text":"module Day04\n\ncontains(a::UnitRange{Int}, b::UnitRange{Int}) =\n    a.start >= b.start && a.stop <= b.stop\n\noverlap(a::UnitRange{Int}, b::UnitRange{Int}) =\n    max(a.start, b.start) <= min(a.stop, b.stop)\n\nfunction read_input(io::IO)\n    fmt = r\"(\\d+)-(\\d+),(\\d+)-(\\d+)\"\n    range_pair(a, b, c, d) = (a:b,c:d)\n    to_range_pair(l) = range_pair((parse(Int, x) for x in match(fmt, l))...)\n    readlines(io) .|> to_range_pair\nend\n\nfunction main(io::IO, io_out::IO=stdout)\n    input = read_input(io)\n    part1 = length(filter(((a, b),)->contains(a,b)||contains(b,a), input))\n    println(io_out, \"Part 1: $part1\")\n    part2 = length(filter(x->overlap(x...), input))\n    println(io_out, \"Part 2: $part2\")\nend\n\nend  # module","category":"page"},{"location":"day04/","page":"Day 04: Camp Cleanup","title":"Day 04: Camp Cleanup","text":"using AOC2022  # hide\n@day 4","category":"page"},{"location":"day04/","page":"Day 04: Camp Cleanup","title":"Day 04: Camp Cleanup","text":"Going to make a nice plot of my input","category":"page"},{"location":"day04/","page":"Day 04: Camp Cleanup","title":"Day 04: Camp Cleanup","text":"using AOC2022.Day04: read_input\nusing DataFrames\nusing CairoMakie\n\ndata = open(read_input, \"../../data/day04.txt\", \"r\")\nto_row((a, b)) = (a0=a.start, a1=a.stop, b0=b.start, b1=b.stop)\ndf = data .|> to_row |> DataFrame\n\nwith_theme(theme_dark()) do\n    CairoMakie.activate!(type = \"svg\")\n    fig = Figure()\n    ax = Axis(fig[1, 1])\n    x = 1:size(df)[1]\n\n    rangebars!(ax, 1:100, df.a0[1:100], df.a1[1:100], color=\"#cc444488\", linewidth = 5)\n    rangebars!(ax, 1:100, df.b0[1:100], df.b1[1:100], color=\"#4444cc88\", linewidth = 5)\n\n    save(\"day04.svg\", fig)\nend\nnothing  # hide","category":"page"},{"location":"day04/","page":"Day 04: Camp Cleanup","title":"Day 04: Camp Cleanup","text":"(Image: Day 4 viz)","category":"page"},{"location":"day06/#Day-06:-Tuning-Trouble","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"","category":"section"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"<div class=\"noweb-label\">file:<i>src/day06.jl</i></div>","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"module Day06\n\nusing ..CircularBuffers\n\nfunction find_start_marker(n::Int, s::String)\n    for i in n:length(s)\n        if allunique(s[i-n+1:i])\n            return i\n        end\n    end\n    nothing\nend\n\n<<day06-circular-buffer>>\n\nfunction main(io::IO, io_out::IO=stdout)\n    input = readline(io)\n    println(io_out, \"Part 1: $(find_start_marker_bitmask(4, input))\")\n    println(io_out, \"Part 2: $(find_start_marker_bitmask(14, input))\")\nend\n\nend  # module","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"using AOC2022  # hide\n@day 6","category":"page"},{"location":"day06/#Let's-go-crazy","page":"Day 06: Tuning Trouble","title":"Let's go crazy","text":"","category":"section"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"This is rather mad, but we can implement a circular buffer, so theoretically we would not need to load all data at once. Call me crazy, but this sliding window thing that is introduced here is typically something seemingly innocuous that comes back with a revenge next week in Advent of Code.","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"<div class=\"noweb-label\">⪡day06-circular-buffer⪢≣</div>","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"function find_start_marker_cb(n::Int, s::String)\n    b = CircularBuffer{Char}(n)\n    for (i, c) in enumerate(s)\n        push!(b, c)\n        if length(b) == n && allunique(b)\n            return i\n        end\n    end\n    -1\nend","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"A circular buffer sits on a Vector of constant size. Each time we push! an element to the buffer, we assign it to the current endloc pointer, overwriting the oldest value. This pointer gets advanced by one, wrapping around when needed.","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"<div class=\"noweb-label\">file:<i>src/CircularBuffers.jl</i></div>","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"module CircularBuffers\n\nexport CircularBuffer, content, pushpop!\n\nmutable struct CircularBuffer{T}\n    content::Vector{T}\n    endloc::Int\n    length::Int\nend\n\n<<circular-buffer-constructors>>\n<<circular-buffer-methods>>\n\nend","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"For now we have two constructors: one that has the buffer size given, and leaves the contents uninitialised, the other where you give prefilled contents and we assume the buffer is completely filled.","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"<div class=\"noweb-label\">⪡circular-buffer-constructors⪢≣</div>","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"CircularBuffer{T}(size::Int) where T =\n    CircularBuffer{T}(Vector{T}(undef, size), 1, 0)\n\nCircularBuffer{T}(content::Vector{T}) where T =\n    CircularBuffer{T}(content, 1, length(content))","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"Julia provides an interface definition for collections. This interface is not in any way regulated by the type system though. It is convenient to build some unit tests.","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"<div class=\"noweb-label\">file:<i>test/runtests.jl</i></div>","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"using Test, AOC2022.CircularBuffers\n\n@testset \"CircularBuffers\" begin\n    b = CircularBuffer{Int}(4)\n    @test isempty(b)\n    foreach(i->push!(b, i), 1:3)\n    @test length(b) == 3\n    @test sort(content(b)) == [1, 2, 3]\n    foreach(i->push!(b, i), 1:3)\n    @test 1 ∈ b && 2 ∈ b && 3 ∈ b\n    @test 4 ∉ b\n    @test length(b) == 4\n    empty!(b)\n    @test isempty(b)\n    @test eltype(b) == Int\nend","category":"page"},{"location":"day06/#General-collection","page":"Day 06: Tuning Trouble","title":"General collection","text":"","category":"section"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"A general collection in Julia is expected to have the following methods defined.","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"<div class=\"noweb-label\">⪡circular-buffer-methods⪢≣</div>","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"Base.isempty(b::CircularBuffer{T}) where T = b.length == 0\n\nfunction Base.empty!(b::CircularBuffer{T}) where T\n    b.length = 0\n    b.endloc = 1\nend\n\nBase.length(b::CircularBuffer{T}) where T = b.length\nBase.checked_length(b::CircularBuffer{T}) where T = b.length","category":"page"},{"location":"day06/#Iterable-collection","page":"Day 06: Tuning Trouble","title":"Iterable collection","text":"","category":"section"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"In many cases we need to see the contents but are not interested in the order of things. The contents function only worries about rearranging stuff when the length of the buffer contents is shorter than the buffer size.","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"<div class=\"noweb-label\">⪡circular-buffer-methods⪢⊞</div>","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"function content(b::CircularBuffer{T}) where T\n    if b.length < length(b.content)\n        start = mod1(b.endloc-b.length, length(b.content))\n        if start+b.length <= length(b.content)\n            b.content[start:start+b.length-1]\n        else\n            rest = start + b.length - length(b.content)\n            [b.content[start:end];b.content[1:rest]]\n        end\n    else\n        b.content\n    end\nend","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"<div class=\"noweb-label\">⪡circular-buffer-methods⪢⊞</div>","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"Base.in(item::T, b::CircularBuffer{T}) where T = item in content(b)\nBase.eltype(::CircularBuffer{T}) where T = T\nBase.unique(b::CircularBuffer{T}) where T = unique(content(b))\nBase.unique(f::Function, b::CircularBuffer{T}) where T = unique(f, content(b))\n\nfunction Base.push!(b::CircularBuffer{T}, item::T) where T\n    b.content[b.endloc] = item\n    b.endloc = mod1(b.endloc+1, length(b.content))\n    b.length = min(length(b.content), b.length+1)\nend\n\nfunction pushpop!(b::CircularBuffer{T}, item::T) where T\n    oldvalue = b.content[b.endloc]\n    b.content[b.endloc] = item\n    b.endloc = mod1(b.endloc+1, length(b.content))\n    oldvalue\nend\n\nBase.allunique(b::CircularBuffer{T}) where T = allunique(content(b))","category":"page"},{"location":"day06/#Using-a-bitset","page":"Day 06: Tuning Trouble","title":"Using a bitset","text":"","category":"section"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"Julia has a datatype BitSet, but that doesn't keep track of the number of items in the set. We can make our own BitCounter. This doesn't exactly count the number of unique items in the set, but doubles are counted only once due to the virtue of the exclusive-or operator. This means that the maximum count is still the length of the set, and this only occurs when all inserted elements are unique.","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"<div class=\"noweb-label\">⪡day06-circular-buffer⪢⊞</div>","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"mutable struct BitCounter{T}\n    bits::T\n    count::T\nend\n\nBitCounter{T}() where T <: Integer = BitCounter{T}(0, 0)\n\nfunction insert!(b::BitCounter{T}, i::T) where T <: Integer\n    if b.bits & (1 << i) == 0\n        b.count += 1\n    end\n    b.bits ⊻= (1 << i)\nend\n\nfunction remove!(b::BitCounter{T}, i::T) where T <: Integer\n    if b.bits & (1 << i) != 0\n        b.count -= 1\n    end\n    b.bits ⊻= (1 << i)\nend\n\nfunction find_start_marker_bitmask(n::Int, s::String)\n    b = CircularBuffer{Char}(Vector{Char}(s[1:n]))\n    x = BitCounter{Int64}()\n    for c in s[1:n]\n        insert!(x, c - 'a')\n    end\n    for (j, c) in enumerate(s[n+1:end])\n        out = pushpop!(b, c)\n        remove!(x, out - 'a')\n        insert!(x, c - 'a')\n        if x.count == n\n            return j+n\n        end\n    end\n    -1\nend","category":"page"},{"location":"day06/#Benchmarks","page":"Day 06: Tuning Trouble","title":"Benchmarks","text":"","category":"section"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"The crazy thing is: the circular buffer version is faster than the first version, which I don't understand at all. What I do understand is why the bitmask version beats all the others.","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"using BenchmarkTools\nusing AOC2022: with_cache\nusing AOC2022.Day06: find_start_marker, find_start_marker_cb, find_start_marker_bitmask\n\ninput = open(readline, \"../../data/day06.txt\", \"r\")\nfind_start_marker(14, input) == \n    find_start_marker_cb(14, input) == \n    find_start_marker_bitmask(14, input)","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"with_cache(\"../artifacts/day06-benchmark-1.bin\") do\n    @benchmark find_start_marker(14, input)\nend","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"with_cache(\"../artifacts/day06-benchmark-2.bin\") do\n    @benchmark find_start_marker_cb(14, input)\nend","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"with_cache(\"../artifacts/day06-benchmark-3.bin\") do\n    @benchmark find_start_marker_bitmask(14, input)\nend","category":"page"},{"location":"day06/#Rust","page":"Day 06: Tuning Trouble","title":"Rust","text":"","category":"section"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"<div class=\"noweb-label\">file:<i>src/day06.rs</i></div>","category":"page"},{"location":"day06/","page":"Day 06: Tuning Trouble","title":"Day 06: Tuning Trouble","text":"mod aoc;\n\nuse crate::aoc::{Result, input_error};\nuse std::io;\n\nfn read_input() -> Result<Vec<u8>> {\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).map_err(input_error)?;\n    Ok(input.bytes().collect())\n}\n\n#[derive(Debug)]\nstruct CircularBuffer<T> {\n    content: Vec<T>,\n    endloc: usize,\n}\n\nimpl<T> CircularBuffer<T> {\n    fn new(content: Vec<T>) -> Self {\n        CircularBuffer { content: content, endloc: 0 }\n    }\n\n    fn push(self: &mut Self, mut item: T) -> T {\n        std::mem::swap(&mut item, &mut self.content[self.endloc]);\n        self.endloc = (self.endloc + 1) % self.content.len();\n        item\n    }\n}\n\n#[derive(Debug)]\nstruct BitSet {\n    bits: usize,\n    count: usize\n}\n\nimpl BitSet {\n    fn new() -> Self { BitSet { bits: 0, count: 0 } }\n    fn insert(self: &mut Self, i: usize) {\n        if self.bits & (1 << i) == 0 {\n            self.count += 1;\n        }\n        self.bits ^= 1 << i;\n    }\n    fn remove(self: &mut Self, i: usize) {\n        if self.bits & (1 << i) != 0 {\n            self.count -= 1;\n        }\n        self.bits ^= 1 << i;\n    }\n}\n\nfn find_start_marker(input: &Vec<u8>, n: usize) -> usize {\n    let mut buf = CircularBuffer::new(input[..n].to_vec());\n    let mut set = BitSet::new();\n    for c in buf.content.iter() {\n        set.insert((*c - b'a') as usize);\n    }\n    let mut pos: usize = n+1;\n    for c in input[n..input.len()-1].iter() {\n        let d = buf.push(*c);\n        set.remove((d - b'a') as usize);\n        set.insert((*c - b'a') as usize);\n        if set.count == n { break; }\n        pos += 1;\n    }\n    pos\n}\n\nfn main() -> Result<()> {\n    let input = read_input()?;\n    println!(\"Part 1: {}\", find_start_marker(&input, 4));\n    println!(\"Part 2: {}\", find_start_marker(&input, 14));\n    Ok(())\n}","category":"page"},{"location":"day08/#Day-08:-Treetop-Tree-House","page":"Day 08: Treetop Tree House","title":"Day 08: Treetop Tree House","text":"","category":"section"},{"location":"day08/","page":"Day 08: Treetop Tree House","title":"Day 08: Treetop Tree House","text":"I feel there must be a smarter solution to this problem.","category":"page"},{"location":"day08/","page":"Day 08: Treetop Tree House","title":"Day 08: Treetop Tree House","text":"<div class=\"noweb-label\">file:<i>src/day08.jl</i></div>","category":"page"},{"location":"day08/","page":"Day 08: Treetop Tree House","title":"Day 08: Treetop Tree House","text":"module Day08\n\nexport read_input, mark_visible, viewing_distance, viewing_distance_2, scenic_score, scenic_score_2\n\nfunction read_input(io::IO)\n    foldl(hcat, readlines(io) .|> l->Vector{Char}(l) .- '0')'\nend\n\nfunction mark_visible_1(treeline::AbstractVector{Int})\n    result = zeros(Int, size(treeline))\n    highest = -1\n    for (i, t) in enumerate(treeline)\n        if t > highest\n            result[i] = 1\n            highest = t\n        end\n    end\n    result\nend\n\nfunction mark_visible(treeline::AbstractVector{Int})\n    mark_visible_1(treeline) .| reverse(mark_visible_1(reverse(treeline)))\nend\n\nfunction mark_visible(forest::AbstractMatrix{Int})\n    m1 = foldl(hcat, mark_visible(c) for c in eachcol(forest))\n    m2 = foldl(hcat, mark_visible(c) for c in eachcol(forest'))'\n    m1 .| m2\nend\n\nfunction viewing_distance(treeline::AbstractVector{Int})\n    result = zeros(Int, size(treeline))\n    for (i, x) in enumerate(treeline)\n        i == 1 && continue\n        for j in 1:i-1\n            result[i] += 1\n            treeline[i-j] >= x && break\n        end\n    end\n    result\nend\n\nfunction scenic_score(forest::AbstractMatrix{Int})\n    s1 = foldl(hcat, viewing_distance(c) for c in eachcol(forest))\n    s2 = foldl(hcat, reverse(viewing_distance(reverse(c))) for c in eachcol(forest))\n    s3 = foldl(hcat, viewing_distance(c) for c in eachcol(forest'))'\n    s4 = foldl(hcat, reverse(viewing_distance(reverse(c))) for c in eachcol(forest'))'\n    s1 .* s2 .* s3 .* s4\nend\n\n<<day08-second-attempt>>\n\nfunction main(io::IO, io_out::IO=stdout)\n    input = read_input(io)\n    visible = mark_visible(input)\n    println(io_out, \"Part 1: $(sum(visible))\")\n    score = scenic_score(input)\n    println(io_out, \"Part 2: $(maximum(score))\")\nend\n\nend  # module","category":"page"},{"location":"day08/","page":"Day 08: Treetop Tree House","title":"Day 08: Treetop Tree House","text":"using AOC2022  # hide\n@day 8","category":"page"},{"location":"day08/#Plot","page":"Day 08: Treetop Tree House","title":"Plot","text":"","category":"section"},{"location":"day08/","page":"Day 08: Treetop Tree House","title":"Day 08: Treetop Tree House","text":"using AOC2022.Day08\nusing CairoMakie\n\nCairoMakie.activate!(type = \"svg\")\nforest = open(read_input, \"../../data/day08.txt\", \"r\")\nxs = collect(Float32, 1:size(forest)[1])\nys = collect(Float32, 1:size(forest)[2])\nfig = Figure(resolution=(1000,350))\nax1 = Axis(fig[1,1], aspect=1)\nax2 = Axis(fig[1,2], aspect=1)\nax3 = Axis(fig[1,3], aspect=1)\nheatmap!(ax1, xs, ys, forest; fxaa=false)\nheatmap!(ax2, xs, ys, mark_visible(forest); fxaa=false)\nheatmap!(ax3, xs, ys, scenic_score(forest).^0.25; fxaa=false)\nsave(\"day08.svg\", fig)","category":"page"},{"location":"day08/","page":"Day 08: Treetop Tree House","title":"Day 08: Treetop Tree House","text":"(Image: My forest)","category":"page"},{"location":"day08/#Second-attempt","page":"Day 08: Treetop Tree House","title":"Second attempt","text":"","category":"section"},{"location":"day08/","page":"Day 08: Treetop Tree House","title":"Day 08: Treetop Tree House","text":"A slightly different approach, keeps track of all distances of heights 0 to 9. Depending on the height map this could be faster, but in practice it isn't.","category":"page"},{"location":"day08/","page":"Day 08: Treetop Tree House","title":"Day 08: Treetop Tree House","text":"<div class=\"noweb-label\">⪡day08-second-attempt⪢≣</div>","category":"page"},{"location":"day08/","page":"Day 08: Treetop Tree House","title":"Day 08: Treetop Tree House","text":"function viewing_distance_2(treeline::AbstractVector{Int})\n    result = zeros(Int, size(treeline))\n    dists = zeros(Int, 10)\n    for (i, x) in enumerate(treeline)\n        result[i] = dists[x+1]\n        dists[x+2:end] .+= 1\n        dists[1:x+1] .= 1\n    end\n    return result\nend\n\nfunction scenic_score_2(forest::AbstractMatrix{Int})\n    s1 = foldl(hcat, viewing_distance_2(c) for c in eachcol(forest))\n    s2 = foldl(hcat, reverse(viewing_distance_2(reverse(c))) for c in eachcol(forest))\n    s3 = foldl(hcat, viewing_distance_2(c) for c in eachcol(forest'))'\n    s4 = foldl(hcat, reverse(viewing_distance_2(reverse(c))) for c in eachcol(forest'))'\n    s1 .* s2 .* s3 .* s4\nend","category":"page"},{"location":"day08/#Benchmarks","page":"Day 08: Treetop Tree House","title":"Benchmarks","text":"","category":"section"},{"location":"day08/","page":"Day 08: Treetop Tree House","title":"Day 08: Treetop Tree House","text":"using BenchmarkTools\nusing AOC2022\nusing AOC2022.Day08\n\ninput = open(read_input, \"../../data/day08.txt\", \"r\")\n\nwith_cache(\"../artifacts/day08-benchmark-1.bin\") do\n    @benchmark scenic_score(input)\nend","category":"page"},{"location":"day08/","page":"Day 08: Treetop Tree House","title":"Day 08: Treetop Tree House","text":"with_cache(\"../artifacts/day08-benchmark-2.bin\") do\n    @benchmark scenic_score_2(input)\nend","category":"page"},{"location":"day13/#Day-13:-Distress-Signal","page":"Day 13: Distress Signal","title":"Day 13: Distress Signal","text":"","category":"section"},{"location":"day13/","page":"Day 13: Distress Signal","title":"Day 13: Distress Signal","text":"<div class=\"noweb-label\">file:<i>src/day13.jl</i></div>","category":"page"},{"location":"day13/","page":"Day 13: Distress Signal","title":"Day 13: Distress Signal","text":"module Day13\n\n<<function-split-on>>\n\nstruct Packet\n    x\nend\n\nfunction read_input(io::IO)\n    get_args(x::Int) = x\n    get_args(x::Vector{Any}) = x .|> get_args\n    get_args(x::Expr) = x.args |> get_args\n    [(Packet(get_args(Meta.parse(i))), Packet(get_args(Meta.parse(j))))\n     for (i, j) in split_on(eachline(io), \"\")]\nend\n\n@enum Check Ok NotOk Continue\n\ncompare(a::Int, b::Int) = a < b ? Ok : (a > b ? NotOk : Continue)\ncompare(a::Int, b::Vector) = compare([a], b)\ncompare(a::Vector, b::Int) = compare(a, [b])\ncompare(a::Vector, b::Vector) =\n    if isempty(a) && isempty(b)\n        Continue\n    elseif isempty(a)\n        Ok\n    elseif isempty(b)\n        NotOk\n    else\n        let x = compare(a[1], b[1])\n            if x == Continue\n                compare(a[2:end], b[2:end])\n            else\n                x\n            end\n        end\n    end\n\nBase.:<(a::Packet, b::Packet) = compare(a.x, b.x) == Ok\n\nfunction main(inp::IO, out::IO)\n    input = read_input(inp)\n    part1 = sum(i for (i, (a, b)) in enumerate(input) if a < b)\n    println(out, \"Part 1: $part1\")\n    packets = foldl(vcat, ([a, b] for (a, b) in input))\n    idx1 = length(filter(p -> p < Packet([[2]]), packets)) + 1\n    idx2 = length(filter(p -> p < Packet([[6]]), packets)) + 2   # [[2]] is also smaller\n    part2 = idx1 * idx2\n    println(out, \"Part 2: $part2\")\nend\n\nend  # module","category":"page"},{"location":"day07/#Day-07:-No-Space-Left-On-Device","page":"Day 07: No Space Left On Device","title":"Day 07: No Space Left On Device","text":"","category":"section"},{"location":"day07/","page":"Day 07: No Space Left On Device","title":"Day 07: No Space Left On Device","text":"<div class=\"noweb-label\">file:<i>src/day07.jl</i></div>","category":"page"},{"location":"day07/","page":"Day 07: No Space Left On Device","title":"Day 07: No Space Left On Device","text":"module Day07\n\nabstract type Console end\nstruct CD <: Console\n    dir :: String\nend\nstruct CDUP <: Console end\nstruct LS <: Console end\nstruct FILE <: Console\n    size :: Int\n    name :: String\n    ext :: Union{Nothing, String}\nend\n\nfilename(f::FILE) = isnothing(f.ext) ? f.name : f.name * f.ext\n\nstruct DIR <: Console\n    name :: String\nend\n\nfunction Base.parse(::Type{CD}, line::String)\n    cd_re = r\"^\\$ cd ([a-z]+)$\"\n    m = match(cd_re, line)\n    isnothing(m) ? nothing : CD(m[1])\nend\n\nfunction Base.parse(::Type{CDUP}, line::String)\n    cdup_re = r\"^\\$ cd \\.\\.$\"\n    m = match(cdup_re, line)\n    isnothing(m) ? nothing : CDUP()\nend\n\nfunction Base.parse(::Type{LS}, line::String)\n    ls_re = r\"^\\$ ls$\"\n    m = match(ls_re, line)\n    isnothing(m) ? nothing : LS()\nend\n\nfunction Base.parse(::Type{FILE}, line::String)\n    file_re = r\"^(\\d+) (\\w+)(\\.\\w+)?$\"\n    m = match(file_re, line)\n    isnothing(m) ? nothing : FILE(parse(Int, m[1]), m[2], m[3])\nend\n\nfunction Base.parse(::Type{DIR}, line::String)\n    dir_re = r\"^dir (\\w+)$\"\n    m = match(dir_re, line)\n    isnothing(m) ? nothing : DIR(m[1])\nend\n\nfunction Base.parse(::Type{Console}, line::String)\n    types = [CD, CDUP, LS, FILE, DIR]\n    for t in types\n        r = parse(t, line)\n        !isnothing(r) && return r\n    end\n    nothing\nend \n\nmutable struct FileTree\n    name::String\n    contents::Dict{String,Union{FILE,FileTree}}\n    size::Int\nend\n\nfunction build_tree(input::Vector{Console})\n    root = FileTree(\"/\", Dict(), 0)\n    cwd = root\n    path = [root]\n    for entry in input\n        if entry isa CD\n            @assert (entry.dir in keys(cwd.contents)) \"dir $(entry.dir) not found in $(keys(cwd.contents))\"\n            @assert (cwd.contents[entry.dir] isa FileTree) \"dir $(entry.dir) seems to be a file $(cwd.contents[entry.dir])\"\n            push!(path, cwd)\n            cwd = cwd.contents[entry.dir]\n        elseif entry isa CDUP\n            path[end].size += cwd.size\n            cwd = pop!(path)\n        elseif entry isa LS\n            # do nothing\n        elseif entry isa FILE\n            cwd.contents[filename(entry)] = entry\n            cwd.size += entry.size\n        elseif entry isa DIR\n            cwd.contents[entry.name] = FileTree(entry.name, Dict(), 0)\n        end\n    end\n    root\nend\n\nfunction flatten(t::FileTree)\n    subdirs::Vector{FileTree} = filter(v -> v isa FileTree, collect(values(t.contents)))\n    subsubdirs::Vector{FileTree} = vcat(map(flatten, subdirs)...)\n    [subdirs; subsubdirs]\nend\n\nfunction read_input(io::IO)\n    filter(!isnothing, readlines(io) .|> l -> parse(Console, l))\nend\n\nconst MB = 1000000\n\nfunction main(io::IO, io_out::IO=stdout)\n    input::Vector{Console} = read_input(io)\n    tree = build_tree(input)\n    flat = flatten(tree)\n    part1 = sum(d.size for d in flat if d.size <= 100000)\n    println(io_out, \"Part 1: $part1\")\n\n    space_free = 70MB - tree.size\n    need_to_free = 30MB - space_free\n    (part2, _) = findmin(d->d.size, filter(d -> d.size >= need_to_free, flat))\n    println(io_out, \"Part 2: $part2\")\nend\n\nend  # module","category":"page"},{"location":"day07/","page":"Day 07: No Space Left On Device","title":"Day 07: No Space Left On Device","text":"using AOC2022  # hide\n@day 7","category":"page"},{"location":"day02/#Day-02:-Rock-Paper-Scissors","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"","category":"section"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"I had a longer solution in Julia, but then I started thinking about tricks in modular arithmetic, and came up with this:","category":"page"},{"location":"day02/#Julia","page":"Day 02: Rock Paper Scissors","title":"Julia","text":"","category":"section"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"<div class=\"noweb-label\">file:<i>src/day02.jl</i></div>","category":"page"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"module Day02\n\nread_input(io::IO) = [(line[1]-'A', line[3]-'X') for line in readlines(io)]\nscore_1((a, b)::Tuple{Int,Int}) = mod(b - a + 1, 3) * 3 + b + 1\nscore_2((a, b)::Tuple{Int,Int}) = b * 3 + mod(a + b - 1, 3) + 1\n\nfunction main(io::IO, io_out::IO=stdout)\n    input = read_input(io)\n    println(io_out, \"Part 1: $(sum(score_1.(input)))\")\n    println(io_out, \"Part 2: $(sum(score_2.(input)))\")\nend\n\nend","category":"page"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"using AOC2022  # hide\n@day 2","category":"page"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"Everything will be explained for the rustic version.","category":"page"},{"location":"day02/#Rust","page":"Day 02: Rock Paper Scissors","title":"Rust","text":"","category":"section"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"For the rustic solution, I did away with any enums and just used u8. I figured out that we can use some modular arithmetic to find the desired choice for rock, paper or scissors. The following equations should all be read modulo 3. ","category":"page"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"R/P/S value\nRock 0\nPaper 1\nScissors 2","category":"page"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"Let's call the two choices a and b, then a wins if a = (b + 1), since paper beats rock, scissors beats papers and rock beats scissors.","category":"page"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"We can also compute the score using modular arithmetic. Look at (b - a + 1); this will say 0 if a won, 1 if it's a draw, and 2 if b won. Since I'm computing on unsigned values I need to make sure that all values remain positive (you can add multiples of 3 for free), so this becomes (4 + b - a):","category":"page"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"<div class=\"noweb-label\">⪡day02-compute-scores⪢≣</div>","category":"page"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"fn score_part_1((a, b): (u8,u8)) -> u32\n    { ((4+b-a)%3 * 3 + b + 1) as u32 }","category":"page"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"For the second part, we may say b to (a + b + 2). We can see this as follows: if we need to win, we need to be exactly b = (a+1), if we need to draw b = a = (a+0), and to lose b = (a-1) = (a+2). So we have:","category":"page"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"code win lose or draw value\n0 lose a + 2\n1 draw a + 0\n2 win a + 1","category":"page"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"If we substitute that into our previous formula for the score, the (4 + b - a) simplifies to simply b.","category":"page"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"<div class=\"noweb-label\">⪡day02-compute-scores⪢⊞</div>","category":"page"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"fn score_part_2((a, b): (u8,u8)) -> u32\n    { (b*3 + (a+b+2)%3 + 1) as u32 }","category":"page"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"The rest is boiler-plate.","category":"page"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"<div class=\"noweb-label\">file:<i>src/day02.rs</i></div>","category":"page"},{"location":"day02/","page":"Day 02: Rock Paper Scissors","title":"Day 02: Rock Paper Scissors","text":"mod aoc;\n\nuse crate::aoc::{Result,Error,input_error};\nuse std::io;\n\nfn read_input() -> Result<Vec<(u8, u8)>> {\n    let mut result = Vec::new();\n    for line in io::stdin().lines() {\n        let l = line.map_err(input_error)?;\n        if l.len() != 3 { return Err(Error::Input(\"unexpected input\".to_string())); }\n        result.push((l.as_bytes()[0] - b'A', l.as_bytes()[2] - b'X'));\n    }\n    Ok(result)\n}\n\n<<day02-compute-scores>>\n\nfn main() -> Result<()> {\n    let input = read_input()?;\n    println!(\"Part 1: {}\", input.iter().copied().map(score_part_1).sum::<u32>());\n    println!(\"Part 2: {}\", input.iter().copied().map(score_part_2).sum::<u32>());\n    Ok(())\n}","category":"page"},{"location":"day10/#Day-10:-Cathode-Ray-Tube","page":"Day 10: Cathode-Ray Tube","title":"Day 10: Cathode-Ray Tube","text":"","category":"section"},{"location":"day10/","page":"Day 10: Cathode-Ray Tube","title":"Day 10: Cathode-Ray Tube","text":"At first I thought \"Yay! The first state-machine exercise!\", I can write a compiler. It's true, I can. But for today's problem it would kinda suck. So I ended up creating a channel that emits the values for each cycle.","category":"page"},{"location":"day10/","page":"Day 10: Cathode-Ray Tube","title":"Day 10: Cathode-Ray Tube","text":"<div class=\"noweb-label\">file:<i>src/day10.jl</i></div>","category":"page"},{"location":"day10/","page":"Day 10: Cathode-Ray Tube","title":"Day 10: Cathode-Ray Tube","text":"module Day10\n\nusing Base: splat\nusing Base.Iterators: map as imap, drop, partition\nexport read_input, run_program\n\nstruct Instruction\n    opcode :: Symbol\n    args :: Vector{Int}\nend\n\nInstruction(opcode::Symbol, args::Int...) = Instruction(opcode, [args...])\n\nchoice(fs::Function ...) = function(l::AbstractString)\n    for f in fs\n        x = f(l)\n        !isnothing(x) && return x\n    end\n    nothing\nend\n\nfunction read_input(inp::IO)\n    addx_instr = r\"addx (-?\\d+)\"\n    parse_addx(l) = match(addx_instr, l) |>\n        m -> isnothing(m) ? nothing : Instruction(:addx, parse(Int, m[1]))\n    noop_instr = r\"noop\"\n    parse_noop(l) = match(noop_instr, l) |>\n        m -> isnothing(m) ? nothing : Instruction(:noop)\n    parse_instr(l) = choice(parse_addx, parse_noop)(l)\n    eachline(inp) .|> parse_instr\nend\n\nfunction run_program(instr)\n    x = 1\n    Channel() do chan\n        cycle() = put!(chan, x)\n        for i in instr\n            if i.opcode === :addx\n                cycle(); cycle()\n                x += i.args[1]\n            else\n                cycle()\n            end\n        end\n    end\nend\n\n\nf2(c, x) = abs((c-1) % 40 - x) <= 1 ? '█' : ' '\n\npart2(input) =\n    join(reshape(enumerate(run_program(input)) .|> splat(f2), 40, 6) |>\n         eachcol .|> String, \"\\n\")\n\nfunction main(inp::IO, out::IO)\n    input = read_input(inp)\n    println(out, \"Part 1: $(part1_iterated(input))\")\n    println(out, \"Part 2:\\n$(part2(input))\")\nend\n\n<<iterators-every>>\n<<day10-part1>>\n\nend  # module","category":"page"},{"location":"day10/","page":"Day 10: Cathode-Ray Tube","title":"Day 10: Cathode-Ray Tube","text":"using AOC2022  # hide\n@day 10","category":"page"},{"location":"day10/#Using-only-pure-iterators","page":"Day 10: Cathode-Ray Tube","title":"Using only pure iterators","text":"","category":"section"},{"location":"day10/","page":"Day 10: Cathode-Ray Tube","title":"Day 10: Cathode-Ray Tube","text":"Now, I would like to make it so, that this doesn't use any memory: input gets piped to parser gets piped to state machine gets piped to solution directly. It turns out that this could be easier in Julia. For one, we can't slice an iterator normally before collecting. We'll have to drop 19, then take every 40th element. There is no function in the standard library to iterate every other nth element, so I implement it here.","category":"page"},{"location":"day10/","page":"Day 10: Cathode-Ray Tube","title":"Day 10: Cathode-Ray Tube","text":"<div class=\"noweb-label\">⪡iterators-every⪢≣</div>","category":"page"},{"location":"day10/","page":"Day 10: Cathode-Ray Tube","title":"Day 10: Cathode-Ray Tube","text":"export every\n\nstruct Every{I}\n    n::Int\n    xs::I\n\n    function Every(n::Int, xs::I) where {I}\n        new{I}(n, xs)\n    end\nend\n\nevery(n::Int, xs) = Every(n, xs)\nBase.eltype(it::Every) = eltype(it.xs)\nBase.IteratorSize(::Type{Every{I}}) where {I} = Base.IteratorSize(I)\nBase.length(it::Every) = length(it.xs) ÷ it.n\nBase.size(it::Every) = (length(it),)\n\nfunction Base.iterate(it::Every)\n    y = iterate(it.xs)\n    isnothing(y) && return nothing\n    value = y[1]\n    for i in 1:it.n-1\n        y = iterate(it.xs, y[2])\n        isnothing(y) && return (value, nothing)\n    end\n    return (value, y[2])\nend\n\nfunction Base.iterate(it::Every, st)\n    isnothing(st) && return nothing\n    y = iterate(it.xs, st)\n    isnothing(y) && return nothing\n    value = y[1]\n    for i in 1:it.n-1\n        y = iterate(it.xs, y[2])\n        isnothing(y) && return (value, nothing)\n    end\n    return (value, y[2])\nend","category":"page"},{"location":"day10/","page":"Day 10: Cathode-Ray Tube","title":"Day 10: Cathode-Ray Tube","text":"For part one this should save us computing the answers that we throw away. However, this is just one multiplication per cycle, so this shouldn't make much of a dent.","category":"page"},{"location":"day10/","page":"Day 10: Cathode-Ray Tube","title":"Day 10: Cathode-Ray Tube","text":"<div class=\"noweb-label\">⪡day10-part1⪢≣</div>","category":"page"},{"location":"day10/","page":"Day 10: Cathode-Ray Tube","title":"Day 10: Cathode-Ray Tube","text":"export part1_collected, part1_collected2, part1_iterated\n\npart1_collected(input) =\n    sum(collect(enumerate(run_program(input)))[20:40:220] .|> splat(*))\n\npart1_collected2(input) =\n    sum(enumerate(collect(run_program(input))[20:40:220]) .|> ((c, x),) -> (c*40-20)*x)\n\npart1_iterated(input) =\n    sum(imap(splat(*), every(40, drop(enumerate(run_program(input)), 19))))","category":"page"},{"location":"day10/","page":"Day 10: Cathode-Ray Tube","title":"Day 10: Cathode-Ray Tube","text":"using AOC2022\nusing AOC2022.Day10\nusing BenchmarkTools\n\ninput = open(read_input, \"../../data/day10.txt\", \"r\")\n@assert (part1_collected(input) == part1_iterated(input))","category":"page"},{"location":"day10/","page":"Day 10: Cathode-Ray Tube","title":"Day 10: Cathode-Ray Tube","text":"with_cache(\"../artifacts/day10-benchmark-1.bin\") do\n    @benchmark part1_collected(input)\nend","category":"page"},{"location":"day10/","page":"Day 10: Cathode-Ray Tube","title":"Day 10: Cathode-Ray Tube","text":"with_cache(\"../artifacts/day10-benchmark-2.bin\") do\n    @benchmark part1_collected2(input)\nend","category":"page"},{"location":"day10/","page":"Day 10: Cathode-Ray Tube","title":"Day 10: Cathode-Ray Tube","text":"with_cache(\"../artifacts/day10-benchmark-3.bin\") do\n    @benchmark part1_iterated(input)\nend","category":"page"},{"location":"#Advent-of-Code-2022","page":"Advent of Code 2022","title":"Advent of Code 2022","text":"","category":"section"},{"location":"","page":"Advent of Code 2022","title":"Advent of Code 2022","text":"(Image: Entangled badge) (Image: Documentation)","category":"page"},{"location":"","page":"Advent of Code 2022","title":"Advent of Code 2022","text":"These are my solutions to Advent of Code 2022.","category":"page"},{"location":"#Literate-programming","page":"Advent of Code 2022","title":"Literate programming","text":"","category":"section"},{"location":"","page":"Advent of Code 2022","title":"Advent of Code 2022","text":"I use a system of literate programming called Entangled. Many of the code blocks you see in this document end up in the actual source code for the modules that I use in the examples. These code blocks are marked with either a filename or a noweb reference. The blocks marked with a noweb reference can be included elsewhere using the <<...>> syntax.","category":"page"},{"location":"#Running-Julia-solutions","page":"Advent of Code 2022","title":"Running Julia solutions","text":"","category":"section"},{"location":"","page":"Advent of Code 2022","title":"Advent of Code 2022","text":"To accommodate easy running of Julia code, I wrote an overarching module. This includes the Julia code for all days, each day in its own module. To run the code for a single day, there is the @day macro. So","category":"page"},{"location":"","page":"Advent of Code 2022","title":"Advent of Code 2022","text":"using AOC2022\n@day 1","category":"page"},{"location":"","page":"Advent of Code 2022","title":"Advent of Code 2022","text":"<div class=\"noweb-label\">file:<i>src/AOC2022.jl</i></div>","category":"page"},{"location":"","page":"Advent of Code 2022","title":"Advent of Code 2022","text":"module AOC2022\n\nusing Printf\nusing Random\nusing Serialization\n\n# Introduced on day 6\ninclude(\"CircularBuffers.jl\")\nusing .CircularBuffers\n\nexport @day, @runall, with_cache\n\nadvent = filter(f -> occursin(r\"day\\d{2}.jl\", f), readdir(@__DIR__))\n\nfor day in advent\n    include(day)\nend\n\nfunction day_gen(n::Int)\n    modname = Symbol(@sprintf \"Day%02u\" n)\n    input_file = joinpath(@__DIR__, @sprintf \"../data/day%02u.txt\" n)\n    quote\n        open($input_file, \"r\") do io_in\n            $modname.main(io_in)\n        end\n    end\nend\n\nfunction frieze()\n    color = (150, 100, 250)\n    chars = # rand(Char(0x1fb00):Char(0x1fb3b), 5)\n        rand(Char(0x1fb90):Char(0x1fb90), 5)\n    colors = [1,1,1,1,1] .|> f -> round.(Int, color ./ f)\n    foldl(*, [\"\\033[38;2;$(r);$(g);$(b)m$(c)\" for ((r,g,b), c) in zip(colors, chars)])\nend\n\nfunction decorated_day(n::Int)\n    modname = Symbol(@sprintf \"Day%02u\" n)\n    input_file = joinpath(@__DIR__, @sprintf \"../data/day%02u.txt\" n)\n    quote\n        n=$n\n        println(\"\\033[48;2;160;20;60m $(frieze())\\033[37m  \\033[1mDay $n                          \\033[m\")\n        buf = PipeBuffer()\n        open($input_file, \"r\") do io_in\n            $modname.main(io_in, buf)\n        end\n        for line in eachline(buf)\n            println(\" $(frieze())\\033[m    $line\")\n        end\n    end\nend\n\nmacro day(n::Int)\n    decorated_day(n)\nend  \n\nmacro runall()\n    function get_day(s)\n        m = match(r\"day(\\d+)\\.jl\", s)\n        isnothing(m) ? nothing : parse(Int, m[1])\n    end\n    runs = filter(!isnothing, advent .|> get_day) .|> decorated_day\n    :(begin $(runs...) end)\nend\n\nfunction with_cache(func::Function, filename::AbstractString)\n    if !isfile(filename)\n        serialize(filename, func())\n    end\n    deserialize(filename)\nend\n\nend  # module","category":"page"},{"location":"day03/#Day-03:-Rucksack-Reorganization","page":"Day 03: Rucksack Reorganization","title":"Day 03: Rucksack Reorganization","text":"","category":"section"},{"location":"day03/","page":"Day 03: Rucksack Reorganization","title":"Day 03: Rucksack Reorganization","text":"Here Julia is being very nice, by allowing me to do set-operation on strings. I was for a moment confused by the column major ordering of Julia's arrays. So in Python the line for part 2, would be something like:","category":"page"},{"location":"day03/","page":"Day 03: Rucksack Reorganization","title":"Day 03: Rucksack Reorganization","text":"for row in input.reshape([-1, 3]):\n    ... # find union of string characters","category":"page"},{"location":"day03/","page":"Day 03: Rucksack Reorganization","title":"Day 03: Rucksack Reorganization","text":"In Julia we have:","category":"page"},{"location":"day03/","page":"Day 03: Rucksack Reorganization","title":"Day 03: Rucksack Reorganization","text":"for col in eachcol(reshape(input, 3, :))\n    ... # do our thing\nend","category":"page"},{"location":"day03/","page":"Day 03: Rucksack Reorganization","title":"Day 03: Rucksack Reorganization","text":"That just takes a bit getting used to I guess.","category":"page"},{"location":"day03/","page":"Day 03: Rucksack Reorganization","title":"Day 03: Rucksack Reorganization","text":"<div class=\"noweb-label\">file:<i>src/day03.jl</i></div>","category":"page"},{"location":"day03/","page":"Day 03: Rucksack Reorganization","title":"Day 03: Rucksack Reorganization","text":"module Day03\n\nsplit_half(s) = begin\n    l = length(s) ÷ 2\n    (s[1:l], s[l+1:end])\nend\n\npriority(c::Char) = islowercase(c) ? c - 'a' + 1 : c - 'A' + 27\n\nfunction main(io::IO, io_out::IO=stdout)\n    input = readlines(io)\n    part1 = input .|> split_half .|> ((a,b),) -> (a ∩ b)[1] .|> priority\n    println(io_out, \"Part 1: $(sum(part1))\")\n    part2 = eachcol(reshape(input, 3, :)) .|> a -> reduce(∩, a)[1] .|> priority\n    println(io_out, \"Part 2: $(sum(part2))\")\nend\n\nend  # module","category":"page"},{"location":"day03/","page":"Day 03: Rucksack Reorganization","title":"Day 03: Rucksack Reorganization","text":"using AOC2022  # hide\n@day 3","category":"page"},{"location":"day03/#Rust","page":"Day 03: Rucksack Reorganization","title":"Rust","text":"","category":"section"},{"location":"day03/","page":"Day 03: Rucksack Reorganization","title":"Day 03: Rucksack Reorganization","text":"I feel so clumsy with Rust... ","category":"page"},{"location":"day03/","page":"Day 03: Rucksack Reorganization","title":"Day 03: Rucksack Reorganization","text":"<div class=\"noweb-label\">file:<i>src/day03.rs</i></div>","category":"page"},{"location":"day03/","page":"Day 03: Rucksack Reorganization","title":"Day 03: Rucksack Reorganization","text":"mod aoc;\n\nuse crate::aoc::{Result, Error}; //input_error};\nuse std::io;\nuse std::collections::HashSet;\n\nfn read_input() -> Vec<String> {\n    io::stdin().lines().map(|l| l.unwrap()).collect()\n}\n\nfn split_half<'a>(s: &'a String) -> (&'a str, &'a str) {\n    let h = s.len()/2;\n    (&s[0..h], &s[h..])\n}\n\nfn priority(c: u8) -> Result<u8> {\n    match c {\n        b'a'..=b'z' => Ok(c - b'a' + 1),\n        b'A'..=b'Z' => Ok(c - b'A' + 27),\n        _           => Err(Error::Value(format!(\"Expected a-zA-Z, got {}\", c)))\n    } \n}\n\nfn main() -> Result<()> {\n    let input = read_input();\n    {\n        let mut total: u32 = 0;\n        for line in &input {\n            let (x, y) = split_half(&line); \n            let a: HashSet<u8> = x.bytes().collect();\n            let b: HashSet<u8> = y.bytes().collect();\n            for i in a.intersection(&b) {\n                total += priority(*i)? as u32;\n            }\n        }\n        println!(\"Part 1: {}\", total);\n    }\n    {\n        // at time of writing, std::iter::ArrayChunks is only in nightly\n        let chunks = input.len() / 3;\n        let mut total = 0;\n        for k in 0..chunks {\n            let a: HashSet<u8> = input[k*3].bytes().collect();\n            let b: HashSet<u8> = input[k*3+1].bytes().collect();\n            let c: HashSet<u8> = input[k*3+2].bytes().collect();\n            let a_b: HashSet<u8> = a.intersection(&b).copied().collect();\n            for i in a_b.intersection(&c) {\n                total += priority(*i)? as u32;\n            }\n        }\n        println!(\"Part 2: {}\", total);\n    } \n    Ok(())\n}","category":"page"}]
}
